{"version":3,"sources":["../api/controllers/ClientController/mcpToken.ts"],"names":[],"mappings":"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","file":"mcpToken.js","sourcesContent":["import randomString from 'crypto-random-string';\nimport * as bcrypt from 'bcrypt';\nimport { RedstoneRequest, RedstoneResponse } from '@Types';\nimport { AuthorizationClient, AuthorizationAccessToken, Client } from '@Models';\n\nasync function findMcpClient(clientId: number): Promise<AuthorizationClient | null> {\n  return AuthorizationClient.findOne({\n    where: { owner: clientId, name: 'MCP' },\n  });\n}\n\nexport async function createMcpToken(req: RedstoneRequest, res: RedstoneResponse) {\n  const clientId = req.session.clientId;\n  const client = await Client.findByPk(clientId);\n  if (!client) {\n    return res.status(404).json({ message: '用户不存在' });\n  }\n\n  const plainSecret = randomString({ length: 64, type: 'url-safe' });\n  const hashedSecret = await bcrypt.hash(plainSecret, 10);\n\n  let authClient = await findMcpClient(clientId);\n\n  if (authClient) {\n    // Revoke existing access tokens\n    await AuthorizationAccessToken.update(\n      { status: 'revoked' },\n      { where: { authorizationClientId: authClient.id, status: 'active' } },\n    );\n    // Update secret\n    authClient.secret = hashedSecret;\n    await authClient.save();\n  } else {\n    authClient = await AuthorizationClient.create({\n      name: 'MCP',\n      description: `MCP credentials for ${client.username}`,\n      redirectURI: 'urn:ietf:wg:oauth:2.0:oob',\n      allowAuthorizationByCredentials: false,\n      secret: hashedSecret,\n      owner: clientId,\n    });\n  }\n\n  return res.status(201).json({\n    message: 'MCP credentials 已生成',\n    clientId: authClient.id,\n    clientSecret: plainSecret,\n  });\n}\n\nexport async function getMcpTokenStatus(req: RedstoneRequest, res: RedstoneResponse) {\n  const clientId = req.session.clientId;\n\n  const authClient = await findMcpClient(clientId);\n  if (!authClient || !authClient.secret) {\n    return res.status(200).json({\n      hasCredentials: false,\n    });\n  }\n\n  return res.status(200).json({\n    hasCredentials: true,\n    clientId: authClient.id,\n    createdAt: authClient.createdAt,\n  });\n}\n\nexport async function revokeMcpToken(req: RedstoneRequest, res: RedstoneResponse) {\n  const clientId = req.session.clientId;\n\n  const authClient = await findMcpClient(clientId);\n  if (!authClient) {\n    return res.status(200).json({ message: '无 MCP credentials' });\n  }\n\n  // Revoke all active access tokens\n  const [revokedCount] = await AuthorizationAccessToken.update(\n    { status: 'revoked' },\n    { where: { authorizationClientId: authClient.id, status: 'active' } },\n  );\n\n  // Clear the secret\n  authClient.secret = null as any;\n  await authClient.save();\n\n  return res.status(200).json({\n    message: 'MCP credentials 已撤销',\n    revokedCount,\n  });\n}\n"],"sourceRoot":"../../../../src"}